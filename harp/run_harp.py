#!/usr/bin/python

"""
Copyright 2015 Medical Research Council Harwell.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

E-mail the developers: sig@har.mrc.ac.uk




**Summary:**

This is the starting file for HARP. It also extends the QMainWindow and acts as the main control of the GUI.

Allows the user to setup a config file in the first tab. This is then saved and added to a processing list. Multiple
config files can be generated and added to the list. The list can then be processed and the status checked
by looking at the processing tab.

USAGE: python harp.py or if using executable in windows .\harp.exe or clicking on the harp.exe icon.

NOTE: QT Designer automatically uses mixed case for its class object names e.g radioButton. This format is not PEP8 but
has not been changed.

-------------------------------------------------------
"""

# Import PyQT module
from PyQt5 import QtCore, QtGui, QtWidgets
import datetime
from multiprocessing import freeze_support
import os
import re
import subprocess
import sys
import tempfile
from pathlib import Path

from PyQt5.QtCore import pyqtSlot
from harp import autofill
from harp import queuejob
import queue
# from ui.mainwindow import Ui_MainWindow
from harp.ui.mainwindow_new import Ui_MainWindow
from harp.processing import ProcessingThread
from harp.imgprocessing import zproject
from harp import manualcrop, version
from harp.appdata import AppData
import multiprocessing as mp


class MainWindow(QtWidgets.QMainWindow):
    """  Class to provide the GUI end of HARP.
    Extends the QMainWindow class (from mainwindow.py) generated by QT Designer
    """

    update1 = QtCore.pyqtSignal(str, str)

    def __init__(self, app):
        """ **Constructor**: Checks the buttons which have been pressed and responds accordingly.

        :param object app: QtGui.QApplication
        :ivar str self.modality: Changes based on the modality chosen. Value should be either 'MicroCT' or 'OPT'
        :ivar boolean self.stop: If True HARP stops pre-processing steps. Wont let the user go process the recon
        :ivar int self.stop_pro_switch: If value 1 HARP stops processes due to user pressing stop
        :ivar int self.count_in: Count used for processing table. Initialized at 0
        :ivar int self.current_row: Row for processing table. Initialized at 0
        :ivar str self.scan_folder: Scan path. Initialized as 'NA' to indicate no data
        :ivar str self.recon_log_path: Recon log path. Initialized as 'NA' to indicate no data
        :ivar str self.f_size_out_gb: File size (in GB). Initialized as '' to indicate no data
        :ivar str self.pixel_size: Pixel size. Initialized as '' to indicate no data
        """
        # Standard setup of class from qt designer Ui class

        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.app = app

        icon_path = Path(__file__).resolve().parent / 'harp.png'
        self.setWindowIcon(QtGui.QIcon(str(icon_path)))

        # March 2019. Temp hide the reprocess to RAS button unyil it's working
        self.ui.checkBoxReprocessToRas.hide()

        # Store app-specific data such as last directory browsed
        self.app_data = AppData()
        self.opttab_populate_patterns()

        self.autofill = autofill.Autofill(self)

        # Initialise various switches
        self.modality = "MicroCT"
        self.stop = None
        self.stop_pro_switch = 0
        self.count_in = 0
        self.current_row = 0
        # Set to "" or NA so that HARP can record in the log and GUI there is no data for these parameters. Will be
        # updated later if parameters are identified.
        self.input_folder = None
        self.scan_folder = "NA"
        self.recon_log_path = "NA"
        self.f_size_out_gb = ""
        self.pixel_size = ""
        # Initalize the pixel size view to blank
        self.ui.lcdNumberPixel.display(self.pixel_size)

        # Get current directory
        # Need to check if script is being run from an pyinstaller created executable or just from python
        if getattr(sys, 'frozen', False):
            self.dir = os.path.dirname(sys.executable)
        elif __file__:
            self.dir = os.path.dirname(__file__)

        # Temp folder for pre-processing log (if in use) and z-project
        self.tmp_dir = tempfile.mkdtemp()

        # Temp file for z-projection
        self.zprojection_output = os.path.join(self.tmp_dir, "max_intensity_z.png")

        # get input folder
        self.ui.pushButtonInput.clicked.connect(self.select_file_in)

        # Get output folder
        self.ui.pushButtonOutput.clicked.connect(self.select_file_out)

        # OPT selection
        self.ui.radioButtonOPT.clicked.connect(self.get_OPT_only)

        # uCT selection
        self.ui.radioButtonuCT.clicked.connect(self.get_uCT_only)

        # If Go button is pressed move onto track progress dialog box
        self.ui.pushButtonGo.clicked.connect(self.add_to_list)

        # Set cropping options
        # Auto crop (disable buttons)
        self.ui.radioButtonAuto.clicked.connect(self.man_crop_off)

        # Crop button on
        self.ui.checkBoxCropYes.clicked.connect(self.crop_switch)

        # Stack type combo box enabled
        self.ui.checkBoxCreateStack.clicked.connect(self.create_stack)

        # Use Old crop (disable buttons)
        self.ui.radioButtonUseOldCrop.clicked.connect(self.man_crop_off)

        self.ui.actionReset_screen_size.triggered.connect(self.reset_screen)

        # Man crop (enable buttons).
        self.ui.radioButtonMan.clicked.connect(self.man_crop_on)

        # derived crop (enable buttons).
        self.ui.radioButtonDerived.clicked.connect(self.derive_on)

        # If the get dimensions button is pressed
        self.ui.pushButtonGetDimensions.clicked.connect(self.get_dimensions)

        # Get the output folder name when manually changed in box
        self.ui.lineEditOutput.textChanged.connect(self.output_folder_changed)

        # Get the input folder name when manually changed in box
        self.ui.lineEditInput.textChanged.connect(self.input_folder_changed)

        # Get recon file manually
        self.ui.pushButtonCTRecon.clicked.connect(self.get_recon_man)

        # Get scan file manually
        self.ui.pushButtonScan.clicked.connect(self.get_scan_man)

        # Get SPR file manually
        self.ui.pushButtonCTSPR.clicked.connect(self.get_SPR_man)

        # Update name
        self.ui.pushButtonUpdate.clicked.connect(self.update_name)

        # Add arbitrary pixel scaling option to list
        self.ui.buttonAddPixelSize.clicked.connect(self.add_pixel_scale)

        # Remove arbitrary pixel scaling option to list
        self.ui.buttonRemovePixelSize.clicked.connect(self.remove_pixel_scale)

        # Start processing recons
        self.ui.pushButtonStart.clicked.connect(self.start_processing)

        # Stop processing recons
        self.ui.pushButtonStop.clicked.connect(self.stop_processing)

        # Add more recons to the list
        self.ui.pushButtonAdd.clicked.connect(self.add_more)

        # About HARP message
        self.ui.actionAbout.triggered.connect(self.about_message)

        # Documentation PDF
        self.ui.actionPDF_user_guide.triggered.connect(self.user_guide)

        # need to monitor when the tab is changed as it determines what qtable uses key commands
        self.ui.tabWidget.currentChanged[int].connect(self.tab_change)

        # Decide which channel to be used for autocrop (this table is on the first tab)
        self.ui.tableWidgetOPT.__class__.keyPressEvent = self.choose_channel_for_crop

        # Set action for key press with pixel scales table
        # self.ui.tableWidgetPixelScales.__class__.keyPressEvent = self.remove_pixel_scale

        # When user double clicks on OPT alternative channel open it on the parameter tab
        self.ui.tableWidgetOPT.doubleClicked.connect(self.change_opt_chn)

        # The IMPC button sets the deafaults for sending data to the DCC
        self.ui.pushButtonIMPC.clicked.connect(self.impc_button)

        #Options tab
        self.ui.pushButtonSaveOptions.clicked.connect(self.opttab_save)
        self.ui.pushButtonResetIgnoreFiles.clicked.connect(self.opttab_reset_ignore_file)
        self.ui.pushButtonResetUSeFiles.clicked.connect(self.opttab_reset_use_files)

        self.center_buttons = [
            self.ui.TCP,
            self.ui.JAX,
            self.ui.UCD,
            self.ui.BCM,
            self.ui.HAR,
            self.ui.CCP
        ]

        cen = self.app_data.center

        for x in self.center_buttons:
            if cen == x.text():
                x.setChecked(True)

        # Accept drag and drop
        self.setAcceptDrops(True)

        # Make line edits accept only digits
        self.ui.lineEditX.setValidator(QtGui.QIntValidator(0, 100000))
        self.ui.lineEditY.setValidator(QtGui.QIntValidator(0, 100000))
        self.ui.lineEditH.setValidator(QtGui.QIntValidator(1, 100000))
        self.ui.lineEditW.setValidator(QtGui.QIntValidator(1, 100000))

        # Shared variable for passing between threads. Not sure if best option. NH
        self.thread_terminate_flag = mp.Value("i", 0)

        # Reprocess mode stuff.
        self.do_reprocess = False
        self.ui.checkBoxReprocessToRas.clicked.connect(self.reporcess_slot)

        self.showMaximized()

    def reporcess_slot(self, checked):
        """
        Revieves signal from the reproces checkbox being pressed.
        If there is a path in the input lineedit, make sure the output path is set to the same directory


        Returns
        -------

        """

        buttons_to_activate = [
            self.ui.radioButtonUseOldCrop
        ]

        buttons_to_deactivate = [
            self.ui.radioButtonAuto,
            self.ui.checkBoxCropYes,
            self.ui.radioButtonMan
        ]



        if checked:
            self.autofill.auto_file_out(True)
            self.do_reprocess = True

            for button in buttons_to_activate:
                button.setChecked(True)
                button.setDisabled(True)

            for button in buttons_to_deactivate:
                button.setDisabled(True)

        else:
            self.do_reprocess = False

            for button in buttons_to_activate:
                button.setDisabled(False)

            for button in buttons_to_deactivate:
                button.setDisabled(False)

    @pyqtSlot()
    def impc_button(self):
        """
        Set the defaults for the IMPC mouse clinics to upload data to the DCC

        :return:
        """

        # Uncheck downscaling checkboxes
        scale_scheck_boxes = [self.ui.checkBoxSF2, self.ui.checkBoxSF3, self.ui.checkBoxSF4, self.ui.checkBoxSF5,
                              self.ui.checkBoxSF6]
        for cb in scale_scheck_boxes:
            cb.setChecked(False)

        # Remove pixel sizes from table
        num_rows = self.ui.tableWidgetPixelScales.rowCount()
        for i in range(0, num_rows):
            self.ui.tableWidgetPixelScales.removeRow(0)

        # Set scaling for croppped recon
        self.ui.checkBoxCropComp.setChecked(True)

    def dropEvent(self, event):
        """ Handles *drop* section for drag and drop of folders.
l
        Overrides dropEvent method from the QMainWindow.
        Resets the inputs and auto-fills in the relevant parameter information.

        Requires dragEnterEvent method.

        :param object event: qt drop event

        .. seealso::
            :func:`reset_inputs()`,
            :func:`autofill_pipe()`
        """
        # list of all the things dragged and dropped
        volume_list = [str(v.toLocalFile()) for v in event.mimeData().urls()]
        # Get the first thing dropped
        vol1 = volume_list[0]
        # Update the input line-edit
        self.ui.lineEditInput.setText(os.path.abspath(str(vol1)))
        # Reset the inputs (apart from the lineEditInput
        self.reset_inputs()
        # autofill parameters
        self.autofill_pipe()

        # JAMES - new feature - switch back to "Parameters" tab if necessary so the user can modify options
        self.ui.tabWidget.setCurrentIndex(0)

        # Clear z-projection data from temp file
        try:
            if os.path.isfile(self.zprojection_output):
                os.remove(self.zprojection_output)
        except OSError as e:
            print("OSError: problem deleting z-projection - ", e)

    def dragEnterEvent(self, event):
        """ Handles *drag* section for drag and drop of folders.

        Overrides dragEnterEvent method from the QMainWindow.
        Required for drag and drop.

        :param event object: qt drag event

        .. seealso::
            :func:`dropEvent()`
        """
        event.accept()

    def tab_change(self):
        """ Changes the tab view for the user.

        On tab 0 (parameters) the qt KeyPressEvent is required for choosing the crop channel for OPT. On tab 1
        (processing) the KeyPressEvent is used for deleting rows on the processing table.

        They KeyPressEvent is therefore updated depending on what tab the user is on.

        Also updates the OPT channels table each tab-change in-case anything has changed.

        .. seealso::
            :func:`choose_channel_for_crop()`,
            :func:`delete_rows()`
        """
        # Update OPT Channel list. As something may have changed on the processing list
        self.autofill.get_channels()

        # Check tab status
        if self.ui.tabWidget.currentIndex() == 0:
            # if on tab 0 (parameters) the keyPressEvent is required for choosing
            # the crop channel for OPT. i.e. key press is linked to the function choose_channel_for_crop()
            self.ui.tableWidgetOPT.__class__.keyPressEvent = self.choose_channel_for_crop
            # self.ui.tableWidgetPixelScales.__class__.keyPressEvent = self.remove_pixel_scale
        elif self.ui.tabWidget.currentIndex() == 1:
            # if on tab 1 (processing) the keyPressEvent is required for deleting rows
            # i.e. key press is linked to the function delete_rows()
            self.ui.tableWidget.__class__.keyPressEvent = self.delete_rows

    def about_message(self):
        """ Short description about what HARP is and its version"""
        QtWidgets.QMessageBox.information(self, 'Message', (
            'HARP v{}: Harwell Automated Recon Processor/ Crop, scale and compress reconstructed images from microCT"'
            ' or OPT data.\n'.format(version.__version__)))

    def user_guide(self):
        """ Loads up pdf help file

        For windows computers uses *os.startfile*. For linux requires *Evince* installed to view the pdf.
        """
        user_man = os.path.join(self.dir, "HARP_user_guide.pdf")

        if sys.platform == "win32" or sys.platform == "win64":
            if not os.path.exists(user_man):
                # if HARP run from exe
                user_man = os.path.join("..", "..", "HARP_user_guide.pdf")
            os.startfile(user_man)
        else:
            opener = "evince"
            subprocess.call([opener, user_man])

    def reset_screen(self):
        """ Reset screen back to default"""
        self.showMaximized()

    def select_file_out(self):
        """ Selects output folder manually

        Updates the line edit box *ui.lineEditOutput*

        .. seealso::
            :func:`choose_channel_for_crop()`,
            :func:`delete_rows()`
        """
        # Get output folder if already defined
        output_folder = str(self.ui.lineEditOutput.text())

        # Check output folders assigned. If assigned open the dialog box in that folder
        if output_folder:
            file_dialog = QtWidgets.QFileDialog(self, 'Open File', output_folder)
        else:
            file_dialog = QtWidgets.QFileDialog(self, 'Open File')

        # get the folder the user selected
        folder = file_dialog.getExistingDirectory(self, "Select Directory")
        # Check if folder variable is defined and update the line edit box (if it not the user has pressed cancel)
        if folder:
            self.ui.lineEditOutput.setText(os.path.abspath(str(folder)))

    def select_file_in(self):
        """ Selects input folder manually and some parameters are auto-filled if possible

        If the the input folder is defined the parameters are reset, the *ui.lineEditInput* is updated and
        the *autofill_pipe()* method is performed which updates various parameters.

        .. seealso::
            :func:`reset_inputs()`,
            :func:`autofill_pipe()`
        """
        # Get input folder if already defined
        input_folder = str(self.ui.lineEditInput.text())

        # If input folder already in dialog, open the browser there
        # JAMES - have replaced the instance creations with static method calls to fix Linux hang
        if input_folder:
            folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Open File', input_folder,
                                                            QtWidgets.QFileDialog.ShowDirsOnly)
            # file_dialog = QtGui.QFileDialog(self, 'Open File', input_folder)
        else:
            if self.app_data.last_dir_browsed:
                input_folder = self.app_data.last_dir_browsed
                # file_dialog = QtGui.QFileDialog(self, 'Open File', input_folder)
                folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Open File', input_folder,
                                                                QtWidgets.QFileDialog.ShowDirsOnly)
            else:
                # file_dialog = QtGui.QFileDialog(self, 'Open File')
                folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Open File', input_folder,
                                                                QtWidgets.QFileDialog.ShowDirsOnly)
                # get the folder the user selected
                # folder = file_dialog.getExistingDirectory(self, "Select Directory", input_folder)

        self.app_data.last_dir_browsed = str(folder)

        # if folder is not defined user has pressed cancel. If defined
        if folder:
            # Reset the inputs in-case this is not the first time someone has selected a file
            self.reset_inputs()
            # Set the input folder
            folder = os.path.abspath(str(folder))
            self.ui.lineEditInput.setText(folder)
            # run all the autofill methods
            self.autofill_pipe()

        # Clear z-projection data from temp file
        try:
            if os.path.isfile(self.zprojection_output):
                os.remove(self.zprojection_output)
        except OSError as e:
            print("OSError: problem deleting z-projection - ", e)

    def autofill_pipe(self, suppress=False):
        """ Performs a series of methods to automatically update parameters

        Uses the methods in the autofill module.

        :param boolean suppress: True if suppression of popup dialog box warnings is required
        :ivar boolean self.crop_box_use: True if a derived croping box is to be used

        .. seealso::
            :func:`autofill.opt_uCT_check()`,
            :func:`autofill.get_name()`,
            :func:`autofill.get_recon_log()`,
            :func:`autofill.auto_file_out()`,
            :func:`autofill.get_channels()`,
            :func:`autofill.auto_get_derived()`,
            :func:`autofill.auto_get_scan()`,
            :func:`autofill.folder_size_approx()`
        """
        # ###################################################
        # Reset parameters settings and instance variables
        # ###################################################
        # Remove the contents of the OPT table
        self.ui.tableWidgetOPT.clearContents()
        # Resets the crop_box_use instance variable
        self.crop_box_use = False
        # Set the crop option back to auto
        self.ui.radioButtonAuto.setChecked(True)
        self.ui.pushButtonGetDimensions.setEnabled(False)
        # Reset the channel name for OPT
        self.ui.lineEditDerivedChnName.setText("")

        # ###################################################
        # Perform autofill of parameter settings
        # ###################################################
        # Autocomplete the name
        self.autofill.get_name(str(self.ui.lineEditInput.text()), self.app_data.suppress_name_warnings)
        # Get the reconLog and associated pixel size
        self.autofill.get_recon_log()
        # check if uCT or opt data
        self.autofill.opt_uCT_check(self.app_data.suppress_modality_warnings)
        # Get the output folder location
        self.autofill.auto_file_out(self.do_reprocess)
        # See what OPT channels are available
        if self.modality == "OPT":
            self.autofill.get_channels()
            self.autofill.auto_get_derived()
        # Automatically identify scan folder
        self.autofill.auto_get_scan()
        # Automatically get SPR file
        self.autofill.auto_get_SPR()
        # Determine size of input folder
        self.autofill.folder_size_approx()
        #self.autofill.contiguous_naming()

    def reset_inputs(self):
        """ Reset the parameter inputs to blank"""
        self.ui.lineEditDate.setText("")
        self.ui.lineEditGroup.setText("")
        self.ui.lineEditAge.setText("")
        self.ui.lineEditLitter.setText("")
        self.ui.lineEditZygosity.setText("")
        self.ui.lineEditSex.setText("")
        self.ui.lineEditName.setText("")
        self.ui.lineEditCTRecon.setText("")
        self.ui.lineEditCTSPR.setText("")
        self.ui.lineEditScan.setText("")
        self.ui.lineEditOutput.setText("")
        self.ui.lcdNumberFile.display(0.0)
        self.ui.lcdNumberPixel.display(0.0)

    def input_folder_changed(self, text):
        """ When user changes the name of the folder manually
        This functions is **deprecated** as the the code almost always takes the input folder directly from the
        line edit box "lineEditInput" anyway.

        Updates the instance variable *input_folder* when the line edit box lineEditInput text has changed

        :param str text: The text from lineEditInput after the text has been changed
        :ivar str self.input_folder: input folder as text
        """
        self.input_folder = text

    def output_folder_changed(self, text):
        """ When user changes the name of the folder manually
        This functions is **deprecated** as the the code almost always takes the input folder directly from the
        line edit box "lineEditOutput" anyway.

        Updates the instance variable *output_folder* when the line edit box lineEditInput text has changed

        :param str text: The text from lineEditInput after the text has been changed
        :ivar str self.output_folder: output folder as text
        """
        self.output_folder = text

    def add_pixel_scale(self):
        """ Enables boxes for scaling by pixel"""
        # if self.ui.checkBoxPixel.isChecked():
        #     self.ui.lineEditPixel.setEnabled(True)
        # else:
        #     self.ui.lineEditPixel.setEnabled(False)

        scale_pixel = str(self.ui.spinPixelSize.value())
        row_count = self.ui.tableWidgetPixelScales.rowCount()

        for i in range(0, row_count):

            row = self.ui.tableWidgetPixelScales.item(i, 0).text()
            if row == scale_pixel:
                QtWidgets.QMessageBox.warning(self, 'Downsample', "Pixel size {} um already in list.".format(scale_pixel))
                return
            elif self.pixel_size and scale_pixel < float(self.pixel_size):
                QtWidgets.QMessageBox.warning(self, 'Downsample', "Pixel size must be larger than the native pixel size ({} um)".format(self.pixel_size))
                return

        self.ui.tableWidgetPixelScales.insertRow(row_count)
        self.ui.tableWidgetPixelScales.setItem(row_count, 0, QtWidgets.QTableWidgetItem(scale_pixel))

    def remove_pixel_scale(self, event):

        selected = self.ui.tableWidgetPixelScales.currentRow()
        self.ui.tableWidgetPixelScales.removeRow(selected)

    def create_stack(self):
        """ Turns stack generation (native resolution) on or off
        """
        if self.ui.checkBoxCreateStack.isChecked():
            self.ui.comboBoxStackType.setEnabled(True)
        else:
            self.ui.comboBoxStackType.setEnabled(False)

    def crop_switch(self):
        """ Turns crop options on or off

        Options enabled and disabled are based on the imaging modality and the current cropping option selected
        """
        # Check if cropping is to occur
        if self.ui.checkBoxCropYes.isChecked():
            self.ui.radioButtonAuto.setEnabled(True)
            self.ui.radioButtonMan.setEnabled(True)
            self.ui.radioButtonUseOldCrop.setEnabled(True)
            self.ui.checkBoxCreateStack.setEnabled(True)

            # Check if OPT modality is selected
            if self.ui.radioButtonOPT.isChecked():
                self.ui.radioButtonDerived.setEnabled(True)
                # Check if derived dimensions is selected
                if self.ui.radioButtonDerived.isChecked():
                    self.ui.lineEditDerivedChnName.setEnabled(True)
            # Check if manual crop is selected
            if self.ui.radioButtonMan.isChecked():
                self.ui.lineEditX.setEnabled(True)
                self.ui.lineEditY.setEnabled(True)
                self.ui.lineEditW.setEnabled(True)
                self.ui.lineEditH.setEnabled(True)
                self.ui.pushButtonGetDimensions.setEnabled(True)
        else:
            # No cropping is required
            self.ui.radioButtonAuto.setEnabled(False)
            self.ui.radioButtonMan.setEnabled(False)
            self.ui.radioButtonUseOldCrop.setEnabled(False)
            self.ui.checkBoxCreateStack.setEnabled(True)
            self.ui.radioButtonDerived.setEnabled(False)
            self.ui.lineEditDerivedChnName.setEnabled(False)
            self.ui.lineEditX.setEnabled(False)
            self.ui.lineEditY.setEnabled(False)
            self.ui.lineEditW.setEnabled(False)
            self.ui.lineEditH.setEnabled(False)
            self.ui.pushButtonGetDimensions.setEnabled(False)

    def man_crop_off(self):
        """ Disables boxes for cropping manually. Used by the radio buttons: radioButtonAuto, radioButtonUseOldCrop."""
        self.ui.lineEditX.setEnabled(False)
        self.ui.lineEditY.setEnabled(False)
        self.ui.lineEditW.setEnabled(False)
        self.ui.lineEditH.setEnabled(False)
        self.ui.pushButtonGetDimensions.setEnabled(False)
        self.ui.lineEditDerivedChnName.setEnabled(False)

    def man_crop_on(self):
        """ Enables boxes for cropping manually.  Used by the radio button: radioButtonMan."""
        self.ui.lineEditX.setEnabled(True)
        self.ui.lineEditY.setEnabled(True)
        self.ui.lineEditW.setEnabled(True)
        self.ui.lineEditH.setEnabled(True)
        self.ui.pushButtonGetDimensions.setEnabled(True)
        self.ui.lineEditDerivedChnName.setEnabled(False)

    def derive_on(self):
        """ Enables options for derived crop. Used by the radio button: radioButtonDerived."""
        self.ui.lineEditDerivedChnName.setEnabled(True)

    def get_OPT_only(self):
        """ Updates parameters options to be OPT only and updates OPT specific autofill operations.

        Used by radio button: radioButtonOPT. Updates instance variable *modality*.

        :ivar str self.modality: Should be "OPT" or "MicroCT". Sets to "OPT" here.

        .. seealso::
            :func:`autofill.get_recon_log()`,
            :func:`autofill.get_channels()`,
        """
        self.modality = "OPT"
        self.ui.lineEditChannel.setEnabled(True)
        self.ui.labelChannel.setEnabled(True)
        self.ui.tableWidgetOPT.setEnabled(True)
        self.ui.radioButtonDerived.setEnabled(True)
        self.ui.checkBoxInd.setEnabled(True)
        if self.ui.radioButtonDerived.isChecked():
            self.ui.lineEditDerivedChnName.setEnabled(True)
        # Autofill operations that OPT modality effects
        self.autofill.get_recon_log()
        self.autofill.get_channels()

    def get_uCT_only(self):
        """ Updates parameters options to be uCT only and updates uCT specific autofill operations.

        Used by radio button: radioButtonuCT. Updates instance variable *modality*.

        :ivar str self.modality: Should be "OPT" or "MicroCT". Sets to "MicroCT" here.

        .. seealso::
            :func:`autofill.get_recon_log()`,
        """
        self.modality = "MicroCT"
        self.ui.lineEditChannel.setEnabled(False)
        self.ui.labelChannel.setEnabled(False)
        self.ui.tableWidgetOPT.setEnabled(False)
        self.ui.radioButtonDerived.setEnabled(False)
        self.ui.lineEditDerivedChnName.setEnabled(False)
        self.ui.checkBoxInd.setEnabled(False)
        # Autofill operations that uCT modality effects
        self.autofill.get_recon_log()

    def update_name(self):
        """ Update the name of the file and folder if the user has changed the name in the "identification" section

        Used by push button: pushButtonUpdate.

        Updates the output name by setting the text directly and updates the "identification" section using the
        autofill.get_name function.

        .. seealso::
            :func:`autofill.get_name()`,
        """
        # Get the input name with directory
        name = str(self.ui.lineEditName.text())
        # Run the get_name method which updates the identification section
        self.autofill.get_name(name)
        # Get output folder name, to start off with this will just be the input name
        output = str(self.ui.lineEditOutput.text())
        path, output_folder_name = os.path.split(output)
        # Now update with self.full_name an instance variable created during autofill.get_name.
        self.ui.lineEditOutput.setText(os.path.abspath(os.path.join(path, self.full_name)))

    def get_recon_man(self):
        """ Get the recon folder manually.

        Lets the user select a recon log file manually and then attempts to get the pixel size from the file given.

        Used by the push button: pushButtonCTRecon

        :ivar str self.recon_log_path: Path of recon log, used again in the pickle file for documentation purposes
        :ivar str self.pixel: Path of recon log, used again in the pickle file for documentation purposes
        :raises TypeError: If self.pixel_size cannot be displayed on the GUI due to incorrect type
        :raises IOError: If file user selected does not exist

        .. seealso::
            :func:`autofill.get_pixel()`,
        """
        # Get the information from the dialog box
        if self.input_folder:
            recon_log_path = QtWidgets.QFileDialog.getOpenFileName(self, 'Select recon log', self.input_folder)[0]
        else:
            recon_log_path = QtWidgets.QFileDialog.getOpenFileName(self, 'Select recon log')[0]

        # If a file was chosen get pixel size and update paramaters
        if recon_log_path:
            try:
                # Set the text on the recon file box on the GUI
                self.ui.lineEditCTRecon.setText(recon_log_path)
                # Check it is an actual path (prob not required)
                self.recon_log_path = os.path.abspath(str(recon_log_path))
                # Open the log file as read only
                recon_log_file = open(self.recon_log_path, 'r')
                # Get pixel size from log file
                self.pixel_size = self.autofill.get_pixel(self.modality, recon_log_file)
                # Display the number on the lcd display
                self.ui.lcdNumberPixel.display(self.pixel_size)
                # Set recon log text
                self.ui.lineEditCTRecon.setText(str(self.recon_log_path))
            except IOError as e:
                # Python standard exception identifies recon file not found
                self.ui.lineEditCTRecon.setText("Error identifying recon file")
                self.pixel_size = ""
                self.ui.lcdNumberPixel.display(self.pixel_size)
            except TypeError as e:
                # self.pixel_size cannot be dsiplayed on the GUI due to incorrect type
                QtWidgets.QMessageBox.warning(self, 'Message',
                                          'Warning: Could not identify pixel value from recon log')
                self.pixel_size = ""
                self.ui.lcdNumberPixel.display(self.pixel_size)

    def get_scan_man(self):
        """ Get the scan folder manually. Uses the push button pushButtonScan."""
        file_dialog = QtWidgets.QFileDialog(self)
        folder = file_dialog.getExistingDirectory(self, "Select Directory")
        if not folder == "":
            self.ui.lineEditScan.setText(folder)

    def get_SPR_man(self):
        """ Get the SPR file manually. Uses the pushButtonCTSPR."""
        file_dialog = QtWidgets.QFileDialog(self)
        file = self.file_dialog.getOpenFileName()[0]
        if not file == "":
            self.ui.lineEditCTSPR.setText(file)

    # ======================================================================
    # User keyboard options for OPT channels
    # ======================================================================
    def choose_channel_for_crop(self, event):
        """ Allows the user to select which channel to use to determine crop dimensions

        If the return button is pressed on a certain row of the opt list this recon will be used for the automatic crop

        :param qt_event event: qt event to be processed for opt channel select
        """
        if event.key() == QtCore.Qt.Key_Return:
            print("key pressed")
            selected = self.ui.tableWidgetOPT.currentRow()
            name = self.ui.tableWidgetOPT.item(selected, 1)
            # check if anything on the OPT list
            if not name:
                print("Selected a row with no opt info")

            elif self.ui.radioButtonOPT.isChecked() and self.ui.radioButtonDerived.isChecked():

                pro = self.ui.tableWidgetOPT.item(selected, 2)
                if pro.text() == "No":
                    QtWidgets.QMessageBox.warning(self, 'Message',
                                              'Warning: Chosen channel to derive dimensions (cropbox) has either\n'
                                              'not been analysed or has not been added onto the processing list')
                elif pro.text() == "On list":
                    in_dir = str(self.ui.lineEditInput.text())
                    path, folder_name = os.path.split(in_dir)
                    if name.text() == folder_name:
                        QtWidgets.QMessageBox.warning(self, 'Message',
                                                  'Warning: Chosen channel to derive dimensions (cropbox) cannot be\n'
                                                  'the current channel unless already processed')
                else:

                    self.ui.lineEditDerivedChnName.setText(name.text())

            else:
                QtWidgets.QMessageBox.warning(self, 'Message',
                                          "Warning: Derived dimension options has not been chosen")

    def change_opt_chn(self):
        """ Allows user to change the current opt channel by double click.

        Autofills some paramers as if the channel folder had been manually selected.

        .. seealso::
            :func:`autofill.reset_inputs()`,
            :func:`autofill_pipe()`
        """
        in_dir = str(self.ui.lineEditInput.text())
        path_out, folder_name = os.path.split(in_dir)
        selected = self.ui.tableWidgetOPT.currentRow()
        name = self.ui.tableWidgetOPT.item(selected, 1)

        # check if anythin on the OPT list
        if not name:
            print("Selected a row with no opt info")
        else:
            self.ui.lineEditInput.setText(os.path.abspath(os.path.join(path_out, str(name.text()))))
            self.reset_inputs()
            self.autofill_pipe()

    # ======================================================================
    # Functions for get Dimensions (z projection)
    # ======================================================================
    def get_dimensions(self):
        """ Allow a user to choose crop dimensions by choosing a region based on the z-projection of the image.

        This z projection is calculated on a seperate thread. Process is as follows:

        1. **start_z_thread** starts a thread using the module zproject
        2. z projection is performed in background giving updates to the "status" section of the GUI
        3. The **zproject_slot** catches any signals
        4. "Z-projection finished" is called and **run_crop** loads a new window.
        5. The user can then select the crop dimensions
        6. When the crop dimensions are selected the crop window is closed and the cropbox parameter is saved on the GUI

        Two important modules used: manualcrop.py and zproject.py

        * zproject performs the zprojection and displays the image.
        * manualcrop.py then gets the dimensions to perform the crop

        IMPORTANT NOTE: The cropping is not actually done here. This is just to get the dimensions.

        :ivar boolean self.stop: If True HARP stops pre-processing steps. Set to None before z projection performed

        .. seealso::
            :func:`start_z_thread()`,
        """
        # get the input folder
        input_folder = str(self.ui.lineEditInput.text())

        # Check input folder is defined
        if not input_folder:
            QtWidgets.QMessageBox.warning(self, 'Message', 'Warning: input directory not defined')
            return
        # Check input folder exists
        if not os.path.exists(input_folder):
            QtWidgets.QMessageBox.warning(self, 'Message', 'Warning: input folder does not exist')
            return
        # Check if folder is empty
        elif os.listdir(input_folder) == []:
            QtWidgets.QMessageBox.warning(self, 'Message', 'Warning: input folder is empty')
            return

        # Disable to button for now
        self.ui.pushButtonGetDimensions.setEnabled(False)
        # Set to None so z_projection doesn't stop unless cancelled
        self.stop = None
        # Let the user know what is going on
        self.ui.textEditStatusMessages.setText("Z-projection in process, please wait")
        # Run the zprojection
        self.start_z_thread()

    def start_z_thread(self):
        """ Starts a thread to perform z projection processing in the background.

        .. seealso::
            :func:`zproject.ZProjectThread()`
        """
        # Get input folder
        input_folder = str(self.ui.lineEditInput.text())
        imglist = self.app_data.getfilelist(input_folder)

        #TODO check for empty list`
        self.z_thread = zproject.Zproject(imglist, self.zprojection_output)
        self.z_thread.update['QString'].connect(self.zproject_slot)
        self.z_thread.start()

    def zproject_slot(self, message):
        """ Listens to the z projection child process.

        Displays all messages to the status section of the parameters tab. Once zprojection is finished opens window
        to display zproject for user to get crop dimensions, using *run_crop*

        .. seealso::
            :func:`run_crop()`
        """
        # Update HARP GUI to status of the zprojection
        self.ui.textEditStatusMessages.setText(message)

        # Check if z projection finished
        if message == "Z-projection finished":
            # Get the crop dimensions and save the file
            self.get_manual_bbox(self.zprojection_output)

    def get_manual_bbox(self, img_path):
        """ Creates the a window to display the z projection used to get crop dimensions

        Creates an object from the crop module. Uses a call back method to get the crop dimensions after the user
        has selected them.

        .. seealso::
            :func:`crop.Crop()`
            :func:`crop_call_back()`
        """
        cropper = manualcrop.Crop(self.crop_ui_callback, img_path, self)
        cropper.show()

    def crop_ui_callback(self, box):
        """ Method to get crop dimension (crop box) from z projecion image.

        Saves the crop dimensions to the line edit boxes on the GUI.

        :param list box: Crop dimensions (crop box) the user selected
        """
        if box is not None:
            self.ui.lineEditX.setText(str(box[0]))
            self.ui.lineEditY.setText(str(box[1]))
            self.ui.lineEditW.setText(str(box[2]))
            self.ui.lineEditH.setText(str(box[3]))
            self.ui.textEditStatusMessages.setText("Manual dimensions selected")
        else:
            self.ui.textEditStatusMessages.setText("No dimensions selected")
        self.ui.pushButtonGetDimensions.setEnabled(True)

    def add_to_list(self):
        """ This adds the recon information onto the "processing tab" also saves a pickle file which includes all the
        parameter information.

        .. seealso::
            :func:`addtolist.start()`
        """
        qj = queuejob.Queuejob(self, self.app_data.center)
        qj.start()

    def start_processing(self):
        """ Starts a thread for processing after the user has pressed the 'start button' (GUI click only)

        .. seealso::
            :func:`start_processing_thread()`
        """
        self.ui.pushButtonStart.setEnabled(False)
        self.ui.pushButtonStop.setEnabled(True)
        self.start_processing_thread()

    def start_processing_thread(self):
        """ Starts a thread to perform all the processing in the background.

        This monitors what recon folder we are processing based on the processing list on the processing tab.

        Summary of steps:
        2. Go through a while loop to see what is the first recon folder on the list that needs processing
        3. Get the location of the relevant config object (config file)
        4. Setup a new thread using **ProcessingThread** to perform the processing in the background.
        5. When the processing signals are caught by the method **processing_slot**
        6. When the signal is sent to say processing is finished for specific recon folder. This method
           (*start_processing_thread**) is run again processing the next recon on the list.


            A tuple of the threads used. (Should only use 1 and then reset when we start again)
            NOTE: Potentially this should just be a class variable (i.e. not self) so would not need to be reset
        :ivar int self.stop_pro_switch: If value 1 HARP stops processes due to user pressing stop. Set at 0 at start.
        :ivar int self.current_row: The current row of processing. Set in the while loop of this method

        .. seealso::
            :func:`processing.ProcessingThread()`
        """

        # ######### James - new code #########

        # Create a thread-safe queue for storing jobs
        job_queue = queue.Queue()  # infinitely many jobs allowed for now

        # A for-loop is used to go through the processing table and adds unstarted jobs to a queue
        # The count refers to the row of the table
        for count in range(0, self.count_in):

            # This gets the status text for this row
            status = self.ui.tableWidget.item(count, 2)

            # Check if the status column has any info
            if not status:
                # if not defined it means there are no recons left to process.
                # Disable and enable buttons which should not be pressed.
                self.ui.pushButtonStart.setEnabled(True)
                self.ui.pushButtonStop.setEnabled(False)
                return
            # check if the status identifies this recon folder is done with
            if re.search("Processing finished", status.text()) or re.search(
                    "error", status.text()):
                # this row has finished, move on
                continue
            # if the status is pending means we can process this recon folder
            if status.text() == "Pending" or status.text() == "Processing Cancelled!":
                # this row needs processing, record the row and add to queue
                folder = self.ui.tableWidget.item(count, 1)
                folder_from_list = str(folder.text())

                # Get the configobject for the row which has been identified from the previous while loop
                configOb_path_from_list = os.path.join(folder_from_list, "Metadata", "configobject.txt")
                job_queue.put(configOb_path_from_list)

        # Reset instance variables
        self.stop_pro_switch = 0
        self.thread_terminate_flag.value = 0 # Terminate when set to 1

        # Finally! Perform the analysis in a thread (using the WorkThread class from Run_processing.py file)
        self.workthread = ProcessingThread(job_queue,
                                           self.thread_terminate_flag,
                                           self.app_data,
                                           self)

        # the update(QString) SENDS signals from the processing thread (wt) to the processing_slot
        self.workthread.update['QString'].connect(self.processing_slot)
        # The kill(Qstring) SENDS signals from the GUI to the function "kill_slot" in the the processing thread
        self.workthread.start()

    def processing_slot(self, message):
        """ listens to the child process and displays any messages.

        Importantly it also recognises when processing is finished for a recon folder and instigates the setup of
        the processing of next recon folder on the list (using **start_processing_thread**)

        Also updates the OPT channels table so it shows if one of the channels is processed.
        TODO: This function is making the GUI hang under Debian. Adding a return to the top of the method frees it
        up, but them we lose the update info

        :param str message: The message sent from the processing thread

        .. seealso::
            :func:`processing.ProcessingThread()`,
            :func:`autofill.get_channels()`
        """
        # print message
        if self.stop_pro_switch:
            return

        # Update the current row
        # First get the item from the table to change (status column)
        item = QtWidgets.QTableWidgetItem()
        self.ui.tableWidget.setItem(self.current_row, 2, item)
        item = self.ui.tableWidget.item(self.current_row, 2)  # NH. Don't think this is needed. Check!
        # Then set the text of this item
        item.setText(message)

        # Set the time of the start of processing
        if message == "Started Processing":
            item = QtWidgets.QTableWidgetItem()
            self.ui.tableWidget.setItem(self.current_row, 3, item)
            item = self.ui.tableWidget.item(self.current_row, 3)  # NH. Don't think this is needed. Check!
            item.setText(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
        # If finished, initiate the processing of the next folder on the list
        if re.search("Processing finished", message) or re.search("error", message):
            print(message)
            item = QtWidgets.QTableWidgetItem()
            self.ui.tableWidget.setItem(self.current_row, 4, item)
            item = self.ui.tableWidget.item(self.current_row, 4)
            item.setText(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
            # Processing has finished for this job, so we should have moved onto the next job (if there is one)
            # self.start_processing_thread()  # JAMES - removed now because the processing thread is still running
            self.workthread = None  # this makes unit testing easier...
            self.current_row += 1  # we instead need to increment the row count as we're moving onto the next

            # update the opt channels table
            self.autofill.get_channels()

        # Depending on the name of files and status update columns may need to be resized
        self.ui.tableWidget.resizeColumnsToContents()

    def add_more(self):
        """ When the add more button is pressed should switch back to the first tab

        Uses the radio button pushButtonAdd

        If there are other OPT channels available tell the user if they want to analyse them as well. If they do
        the GUI is updated as if this channel has been manually selected.

        .. seealso::
            :func:`reset_inputs()`,
            :func:`autofill_pipe()`
        """
        # change tab
        self.ui.tabWidget.setCurrentIndex(0)
        # The first and second tab have different key handling so this is updated
        # - opt table to handle key press events
        self.ui.tableWidgetOPT.__class__.keyPressEvent = self.choose_channel_for_crop

        # Get directory names
        in_dir = str(self.ui.lineEditInput.text())
        path_in, folder_name = os.path.split(in_dir)

        # Check if user wants to use the next opt channel available (OPT only)
        if self.modality == "OPT":
            # check if a channel which has not been analysed
            n = self.ui.tableWidgetOPT.rowCount()
            for i in range(n):
                processed = self.ui.tableWidgetOPT.item(i, 2)
                # Check if OPT channel not processed
                if processed.text() == "No":
                    # See if user wants the channel to be processed
                    reply = QtWidgets.QMessageBox.question(self, 'Message', 'Would you like to setup the next '
                                                                        'OPT Channel?',
                                                       QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                                                       QtWidgets.QMessageBox.No)
                    # If yes add to list
                    if reply == QtWidgets.QMessageBox.Yes:
                        name = self.ui.tableWidgetOPT.item(i, 1)
                        self.ui.lineEditInput.setText(os.path.abspath(os.path.join(path_in, str(name.text()))))
                        self.reset_inputs()
                        self.autofill_pipe()
                        return
                    # if no, do nothing.
                    if reply == QtWidgets.QMessageBox.No:
                        return

    def stop_processing(self):
        """ kills the current process

        :ivar tuple self.workthread: A tuple of the threads used. Reset here before the next process.
        :ivar int self.stop_pro_switch: If value 1 HARP stops processes due to user pressing stop. Set at 1 here.

        """
        print("Stop!!")

        # JAMES EDIT: only set processing cancelled flag if there is actually a job there
        if self.current_row < self.count_in:
            item = QtWidgets.QTableWidgetItem()
            self.ui.tableWidget.setItem(self.current_row, 2, item)
            item = self.ui.tableWidget.item(self.current_row, 2)
            item.setText("Processing Cancelled!")

        self.thread_terminate_flag.value = 1

        self.ui.pushButtonStart.setEnabled(True)
        self.ui.pushButtonStop.setEnabled(False)

        self.stop_pro_switch = 1


    def delete_rows(self, event):
        """ Deletes a row from the processing list on the processing tab

        If the delete button is pressed on a certain row the recon is taken off the list to be processed

        :param qt_event event: Key press event
        :ivar int self.count_in: Used to monitor the number of rows in use (used in the addtolist module)
        """
        # Check if key event is the delete key
        if event.key() == QtCore.Qt.Key_Delete:
            # Gets the current selected row
            selected = self.ui.tableWidget.currentRow()
            # Get the status of that row
            status = self.ui.tableWidget.item(selected, 2)
            if status:
                # check if processing has finished or not started
                print("status", status.text())
                if (status.text() == "Pending" or re.search("Processing finished", status.text())
                    or status.text() == "Processing Cancelled!" or re.search("error", status.text())):

                    print("Deleted row")
                    self.ui.tableWidget.removeRow(selected)

                    # The count_in will now be one less (i think...)
                    self.count_in -= 1
                    self.current_row -= self.current_row  # JAMES - also need to decrement the current row

                else:
                    QtWidgets.QMessageBox.warning(self, 'Message',
                                              'Warning: Can\'t delete a row that is currently being processed.'
                                              '\nSelect "Stop", then remove')

    def opttab_populate_patterns(self):
        """
        Read the patterns to ignore from the user appdata
        :return:
        """
        self.ui.textEditIgnoreFiles.setText('  '.join(self.app_data.files_to_ignore))
        self.ui.textEditUseFile.setText('  '.join(self.app_data.files_to_use))
        self.ui.checkBoxSuppressModalityWarning.setChecked(self.app_data.suppress_modality_warnings)
        self.ui.checkBoxSuppressNameWarnings.setChecked(self.app_data.suppress_name_warnings)


    def opttab_save(self):

        ignore_patterns = str(self.ui.textEditIgnoreFiles.toPlainText()).split()
        self.app_data.files_to_ignore = ignore_patterns

        use_patterns = str(self.ui.textEditUseFile.toPlainText()).split()
        self.app_data.files_to_use = use_patterns

        self.app_data.suppress_name_warnings = self.ui.checkBoxSuppressNameWarnings.isChecked()
        self.app_data.suppress_modality_warnings = self.ui.checkBoxSuppressModalityWarning.isChecked()

        for x in self.center_buttons:
            if x.isChecked():
                self.app_data.center = str(x.text())
        self.app_data.save()

    def opttab_reset_ignore_file(self):
        self.app_data.reset_ignore_file()
        self.opttab_populate_patterns()


    def opttab_reset_use_files(self):
        self.app_data.reset_use_file()
        self.opttab_populate_patterns()

    # ======================================================================
    # Kill HARP functions
    #======================================================================
    def closeEvent(self, event):
        """ Overides QMainWindow closeEvent

        NOTE: Function name has to be mixed case format as it is from qt

        Performs a loop through the item list and checks if any process still running
        :param qt_event event: qt close event (when HARP is closed)
        """
        self.app_data.save()

        print("Close event")
        # First check if a process still running by looking through the processing table and checking the status
        # column. The switch variable records whether processing is live or dead.
        count = 0
        while True:
            # This gets the status text
            status = self.ui.tableWidget.item(count, 2)
            if not status:
                switch = "dead"
                break
            if status:
                if (status.text() != "Pending" and not re.search("Processing finished", status.text())
                        and status.text() != "Processing Cancelled!" and not re.search("error", status.text())):
                    switch = "live"
                    break
            count += 1

        # if processing switch live, dont shutdown
        if switch == "live":

            reply = QtWidgets.QMessageBox.question(self, "Confirm quit", "Warning: all processing jobs will be cancelled. "
                                                     "Are you sure you want to quit?",
                                               QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)

            if reply == QtWidgets.QMessageBox.Yes:  # Kill processing and accept close event
                self.stop_processing()
                event.accept()
            else:
                event.ignore()

        # Processing dead so ask user if they want to quit.
        else:
            reply = QtWidgets.QMessageBox.question(self, "Confirm quit", "Are you sure you want to quit?",
                                               QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)

            if reply == QtWidgets.QMessageBox.Yes:
                event.accept()
            else:
                event.ignore()


def main():
    freeze_support()
    app = QtWidgets.QApplication(sys.argv)
    ex = MainWindow(app)
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
